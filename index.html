<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Promise Quest: The Heart Universe</title>
    <style>
        /* --- CSS STYLING --- */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Montserrat:wght@300;500&display=swap');

        :root {
            --primary: #ff4d88;
            --secondary: #8b5cf6;
            --dark: #0f172a;
        }

        /* RESET & MOBILE SCROLL LOCK */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none; /* Critical: Prevents page scrolling on mobile */
        }

        body {
            background-color: var(--dark);
            overflow: hidden;
            font-family: 'Montserrat', sans-serif;
            color: white;
            width: 100vw;
            height: 100vh;
            position: fixed;
            cursor: none; /* Hide default cursor generally */
        }

        /* --- CUSTOM CURSOR (Visual Only) --- */
        #custom-cursor {
            position: fixed;
            top: 0;
            left: 0;
            width: 40px;
            height: 40px;
            pointer-events: none; /* Let clicks pass through */
            z-index: 100000;
            transform: translate(-50%, -50%);
            mix-blend-mode: screen;
            will-change: transform, left, top;
        }

        #custom-cursor svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 10px var(--primary));
            animation: pulse 1.5s infinite ease-in-out;
        }

        /* --- UI LAYERING --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Default: click through to canvas */
            z-index: 10;
        }

        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, rgba(15, 23, 42, 0.6), rgba(15, 23, 42, 0.95));
            transition: opacity 0.5s ease;
            pointer-events: auto; /* Buttons on screens must be clickable */
        }

        .hidden {
            opacity: 0;
            pointer-events: none !important;
        }

        /* TYPOGRAPHY */
        h1 {
            font-family: 'Cinzel', serif;
            font-size: 2.8rem;
            background: linear-gradient(to right, #fff, var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 77, 136, 0.5);
            margin-bottom: 1rem;
            text-align: center;
            padding: 0 20px;
        }

        p.subtext {
            font-size: 1rem;
            letter-spacing: 3px;
            opacity: 0.8;
            margin-bottom: 3rem;
            text-align: center;
        }

        /* BUTTONS */
        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 16px 45px;
            font-size: 1.2rem;
            border-radius: 50px;
            font-family: 'Cinzel', serif;
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(255, 77, 136, 0.2);
            cursor: pointer; /* Force pointer cursor on buttons */
        }

        button:active {
            transform: scale(0.95);
            background: var(--primary);
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 30px;
            width: 100%;
            text-align: center;
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            text-shadow: 0 0 10px var(--primary);
            pointer-events: none;
        }

        /* POPUP MESSAGE */
        #message-area {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        .popup-text {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: white;
            text-shadow: 0 0 20px var(--secondary);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            padding: 0 20px;
        }

        .popup-text.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* MOBILE JOYSTICK */
        #joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(4px);
            display: none; /* Active via JS check */
            pointer-events: auto; /* MUST be auto to catch touch events */
            z-index: 100;
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: rgba(255, 77, 136, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px var(--primary);
            pointer-events: none;
        }

        /* KEYFRAMES */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.2); opacity: 1; filter: drop-shadow(0 0 15px var(--primary)); }
        }

        /* RESPONSIVE */
        @media (max-width: 1024px) {
            #joystick-zone { display: block; } /* Show joystick on mobile/tablet */
            #custom-cursor { display: none; } /* Hide decorative cursor on touch */
            body { cursor: auto; } /* Reset cursor for native touch feel */
        }
    </style>
</head>
<body>

    <div id="custom-cursor">
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#ff9a9e;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#ff4d88;stop-opacity:1" />
                </linearGradient>
            </defs>
            <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" fill="url(#grad1)" stroke="white" stroke-width="1"/>
        </svg>
    </div>

    <div id="ui-layer">
        <div id="start-screen" class="screen">
            <h1>Promise Quest</h1>
            <p class="subtext">THE HEART UNIVERSE</p>
            <button id="start-btn">Enter World</button>
        </div>

        <div id="hud" class="hidden">0 / 5 Promises</div>

        <div id="message-area">
            <div id="popup-text" class="popup-text"></div>
        </div>

        <div id="end-screen" class="screen hidden" style="background: rgba(15, 23, 42, 0.0); pointer-events: none;">
            <div style="background: rgba(15, 23, 42, 0.9); padding: 40px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2); backdrop-filter: blur(15px); pointer-events: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.5);">
                <h1>This Promise Is Forever</h1>
                <p class="subtext" style="color: #ff9a9e; margin-top: 10px;">With you. Always.</p>
                <button id="restart-btn" style="margin-top: 20px;">Replay</button>
            </div>
        </div>

        <div id="joystick-zone">
            <div id="joystick-knob"></div>
        </div>
    </div>

    <div id="canvas-container" style="position: absolute; top:0; left:0; width:100%; height:100%; z-index: 0;"></div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';

        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                bg: 0x0f172a,
                player: 0xff4d88,
                fragment: 0x6a11cb,
                star: 0xffffff,
                heart: 0xe11d48
            },
            promises: [
                "I promise to support your dreams.",
                "I promise to protect your smile.",
                "I promise to listen deeply.",
                "I promise to choose you daily.",
                "I promise to love you forever."
            ],
            speed: 0.18, // Slightly faster for mobile responsiveness
            friction: 0.90
        };

        // --- GLOBALS ---
        let scene, camera, renderer;
        let player, playerGlow;
        let fragments = [];
        let particles, starField, finalHeartSystem;
        let gameState = 'start';
        let collectedCount = 0;
        
        // Input
        const input = { up: false, down: false, left: false, right: false };
        const velocity = new THREE.Vector3();
        
        // Cursor
        const cursorEl = document.getElementById('custom-cursor');
        const mouse = { x: window.innerWidth/2, y: window.innerHeight/2 };
        const targetMouse = { x: window.innerWidth/2, y: window.innerHeight/2 };
        
        // Audio
        let audioCtx;

        // --- INITIALIZATION ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.025);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 6, 12);

            // Renderer (Mobile Optimization: Check Pixel Ratio)
            renderer = new THREE.WebGLRenderer({ antialias: window.devicePixelRatio < 2, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2x
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 2.5); 
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffd700, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // World
            createEnvironment();
            createPlayer();
            
            // Listeners
            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            
            // Joystick
            setupJoystick();
            
            // Loop
            animate();
        }

        // --- ASSET GENERATION ---
        function createGlowTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.4, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        // --- WORLD BUILDING ---
        function createEnvironment() {
            // Floor
            const planeGeo = new THREE.PlaneGeometry(300, 300);
            const planeMat = new THREE.MeshStandardMaterial({ 
                color: 0x1e1b4b, 
                roughness: 0.7, 
                metalness: 0.2,
            });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.5;
            scene.add(plane);

            // Stars (Optimized for Mobile)
            const starGeo = new THREE.BufferGeometry();
            const starCount = 800; // Reduced count
            const positions = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i++) {
                positions[i] = (Math.random() - 0.5) * 150;
                if(i % 3 === 1) positions[i] = Math.abs(positions[i]) + 2; 
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMat = new THREE.PointsMaterial({
                color: CONFIG.colors.star,
                size: 0.25,
                transparent: true,
                opacity: 0.8
            });
            starField = new THREE.Points(starGeo, starMat);
            scene.add(starField);
        }

        function createPlayer() {
            // Sphere (Low Poly for mobile)
            const geo = new THREE.SphereGeometry(0.5, 24, 24);
            const mat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.player,
                emissive: 0xff0044,
                emissiveIntensity: 0.5,
                roughness: 0.1
            });
            player = new THREE.Mesh(geo, mat);
            player.position.set(0, 1, 0);
            
            // Glow
            const spriteMat = new THREE.SpriteMaterial({ 
                map: createGlowTexture('rgba(255, 77, 136, 1)'),
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            playerGlow = new THREE.Sprite(spriteMat);
            playerGlow.scale.set(3, 3, 1);
            player.add(playerGlow);

            // Point Light
            const pLight = new THREE.PointLight(CONFIG.colors.player, 1.2, 15);
            player.add(pLight);

            scene.add(player);
        }

        function spawnFragments() {
            fragments.forEach(f => scene.remove(f.mesh));
            fragments = [];

            const locations = [
                {x: 0, z: -12}, {x: -10, z: -4}, {x: 10, z: -4}, {x: -7, z: 8}, {x: 7, z: 8}
            ];

            locations.forEach((pos, i) => {
                const geo = new THREE.OctahedronGeometry(0.6, 0);
                const mat = new THREE.MeshPhongMaterial({
                    color: CONFIG.colors.fragment,
                    emissive: CONFIG.colors.secondary,
                    emissiveIntensity: 0.6
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(pos.x, 1.5, pos.z);

                // Glow
                const glow = new THREE.Sprite(new THREE.SpriteMaterial({
                    map: createGlowTexture('rgba(139, 92, 246, 1)'),
                    transparent: true,
                    blending: THREE.AdditiveBlending
                }));
                glow.scale.set(3, 3, 1);
                mesh.add(glow);

                scene.add(mesh);
                fragments.push({ mesh, baseY: 1.5, offset: i, text: CONFIG.promises[i] });
            });
        }

        // --- AUDIO SYSTEM ---
        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            
            // Simple Ambient Drone
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.value = 110; 
            osc.type = 'triangle';
            gain.gain.value = 0.03; // Very subtle
            osc.connect(gain).connect(audioCtx.destination);
            osc.start();
        }

        function playSound(type) {
            if(!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain).connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'collect') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.exponentialRampToValueAtTime(880, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            } else if (type === 'beat') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(60, now);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.2);
            }
        }

        // --- GAMEPLAY LOGIC ---
        function startGame() {
            gameState = 'playing';
            initAudio(); // Initialize audio on user interaction
            spawnFragments();
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            collectedCount = 0;
            updateHUD();
        }

        function updatePhysics() {
            if(gameState !== 'playing') return;

            // Apply Force from Keys
            if (input.up) velocity.z -= CONFIG.speed;
            if (input.down) velocity.z += CONFIG.speed;
            if (input.left) velocity.x -= CONFIG.speed;
            if (input.right) velocity.x += CONFIG.speed;

            // Friction
            velocity.multiplyScalar(CONFIG.friction);
            player.position.add(velocity);

            // Boundaries
            const limit = 40;
            player.position.x = THREE.MathUtils.clamp(player.position.x, -limit, limit);
            player.position.z = THREE.MathUtils.clamp(player.position.z, -limit, limit);

            // Rotation Visuals
            player.rotation.x = velocity.z * 2;
            player.rotation.z = -velocity.x * 2;
            
            // Pulse Effect
            playerGlow.scale.setScalar(3 + Math.sin(Date.now() * 0.005) * 0.5);
        }

        function updateCollisions() {
            if(gameState !== 'playing') return;

            for (let i = fragments.length - 1; i >= 0; i--) {
                const f = fragments[i];
                
                // Animation
                f.mesh.rotation.y += 0.02;
                f.mesh.position.y = f.baseY + Math.sin(Date.now()*0.002 + f.offset)*0.3;

                // Check Distance
                if (player.position.distanceTo(f.mesh.position) < 1.8) {
                    collectFragment(i);
                }
            }
        }

        function collectFragment(index) {
            const f = fragments[index];
            createExplosion(f.mesh.position);
            playSound('collect');
            
            // Show Text
            const popup = document.getElementById('popup-text');
            popup.innerText = f.text;
            popup.classList.add('visible');
            setTimeout(() => popup.classList.remove('visible'), 2500);

            // Logic
            scene.remove(f.mesh);
            fragments.splice(index, 1);
            collectedCount++;
            updateHUD();

            if (fragments.length === 0) {
                setTimeout(triggerEnding, 1500);
            }
        }

        function updateHUD() {
            document.getElementById('hud').innerText = `${collectedCount} / 5 Promises`;
        }

        function createExplosion(pos) {
            const count = 20; // Reduced for mobile
            const geo = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            for(let i=0; i<count; i++) {
                positions.push(pos.x, pos.y, pos.z);
                velocities.push(
                    (Math.random()-0.5)*0.3,
                    (Math.random()-0.5)*0.3,
                    (Math.random()-0.5)*0.3
                );
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true });
            const pts = new THREE.Points(geo, mat);
            scene.add(pts);

            // Animate once
            const startTime = Date.now();
            function animateExplosion() {
                const elapsed = Date.now() - startTime;
                if (elapsed > 1000) {
                    scene.remove(pts);
                    return;
                }
                
                const posAttr = pts.geometry.attributes.position;
                for(let i=0; i<count; i++) {
                    posAttr.setXYZ(i, 
                        posAttr.getX(i) + velocities[i*3],
                        posAttr.getY(i) + velocities[i*3+1],
                        posAttr.getZ(i) + velocities[i*3+2]
                    );
                }
                posAttr.needsUpdate = true;
                mat.opacity = 1 - (elapsed/1000);
                requestAnimationFrame(animateExplosion);
            }
            animateExplosion();
        }

        // --- ENDING ---
        function triggerEnding() {
            gameState = 'ending';
            document.getElementById('hud').classList.add('hidden');
            
            createFinalHeart();

            setInterval(() => playSound('beat'), 1200);

            setTimeout(() => {
                document.getElementById('end-screen').classList.remove('hidden');
            }, 4000);
        }

        function createFinalHeart() {
            const geo = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color(CONFIG.colors.heart);
            const count = 2500; // Reduced for mobile

            for(let i=0; i<count; i++) {
                const t = Math.random() * Math.PI * 2;
                
                // Heart Formula
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 5;

                const s = 0.35;
                x *= s; y *= s; z *= s;
                y += 5;

                positions.push(x, y, z);
                colors.push(color.r, color.g, color.b + (Math.random()*0.3));
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 0.15, vertexColors: true, blending: THREE.AdditiveBlending,
                transparent: true, opacity: 0
            });

            finalHeartSystem = new THREE.Points(geo, mat);
            scene.add(finalHeartSystem);

            // Fade In
            let op = 0;
            const timer = setInterval(() => {
                op += 0.01;
                mat.opacity = op;
                if(op >= 1) clearInterval(timer);
            }, 30);
        }

        // --- INPUT HANDLING ---
        function onKeyDown(e) {
            const key = e.code;
            if(key === 'ArrowUp' || key === 'KeyW') input.up = true;
            if(key === 'ArrowDown' || key === 'KeyS') input.down = true;
            if(key === 'ArrowLeft' || key === 'KeyA') input.left = true;
            if(key === 'ArrowRight' || key === 'KeyD') input.right = true;
        }

        function onKeyUp(e) {
            const key = e.code;
            if(key === 'ArrowUp' || key === 'KeyW') input.up = false;
            if(key === 'ArrowDown' || key === 'KeyS') input.down = false;
            if(key === 'ArrowLeft' || key === 'KeyA') input.left = false;
            if(key === 'ArrowRight' || key === 'KeyD') input.right = false;
        }

        function onMouseMove(e) {
            targetMouse.x = e.clientX;
            targetMouse.y = e.clientY;
        }

        function setupJoystick() {
            const zone = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');
            let startX, startY;

            zone.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Stop Browser Scroll
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
            }, {passive: false});

            zone.addEventListener('touchmove', (e) => {
                e.preventDefault(); // Stop Browser Scroll
                const t = e.touches[0];
                const dx = t.clientX - startX;
                const dy = t.clientY - startY;
                const dist = Math.min(Math.hypot(dx, dy), 35);
                const angle = Math.atan2(dy, dx);
                
                knob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
                
                // Map joystick to keyboard-like input
                input.right = dx > 10;
                input.left = dx < -10;
                input.down = dy > 10;
                input.up = dy < -10;
            }, {passive: false});

            zone.addEventListener('touchend', (e) => {
                e.preventDefault();
                knob.style.transform = 'translate(-50%, -50%)';
                input.up = input.down = input.left = input.right = false;
            });
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Update Cursor
            mouse.x += (targetMouse.x - mouse.x) * 0.2;
            mouse.y += (targetMouse.y - mouse.y) * 0.2;
            if(cursorEl) {
                cursorEl.style.left = mouse.x + 'px';
                cursorEl.style.top = mouse.y + 'px';
            }

            // Game Logic
            updatePhysics();
            updateCollisions();

            // Camera Logic
            if(gameState === 'ending') {
                const target = new THREE.Vector3(0, 8, 20);
                camera.position.lerp(target, 0.02);
                camera.lookAt(0, 5, 0);
                if(finalHeartSystem) {
                    finalHeartSystem.rotation.y += 0.005;
                    const s = 1 + Math.sin(Date.now()*0.003)*0.05;
                    finalHeartSystem.scale.set(s,s,s);
                }
            } else {
                const targetPos = new THREE.Vector3(player.position.x, player.position.y + 10, player.position.z + 14);
                camera.position.lerp(targetPos, 0.08);
                camera.lookAt(player.position);
            }

            if(starField) starField.rotation.y += 0.0005;

            renderer.render(scene, camera);
        }

        // Bind Buttons
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', () => location.reload());

        // Run
        init();

    </script>
</body>
</html>
